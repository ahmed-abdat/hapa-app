import type { CollectionBeforeChangeHook } from 'payload'
import type { Post } from '@/payload-types'
import { generateSEOTitle, extractPlainTextFromLexical, truncateText, SEO_LIMITS } from '@/utilities/seo'
import { seoConfig } from '../config/seo.config'
import { SEO_CONFIG, type SupportedLocale } from '@/config/seo-constants'

/**
 * Auto-populate SEO fields when they are empty
 * This hook runs before change and only populates empty fields
 * It respects manually entered values and won't override them
 */
export const autoPopulateSEO: CollectionBeforeChangeHook<Post> = async ({
  data,
  req,
  operation,
  originalDoc,
}) => {
  try {
    // Debug: Log the hook trigger
    if (process.env.NODE_ENV === 'development') {
      console.log('[SEO Auto-populate] Hook triggered:', {
        operation,
        locale: req.locale,
        status: data?._status,
        hasTitle: !!data?.title,
        hasContent: !!data?.content,
        hasMeta: !!data?.meta
      })
    }
    
    // Only run on create and update operations
    if (operation !== 'create' && operation !== 'update') {
      return data
    }

    // Skip if we're in a validation context to prevent circular issues
    if (req.context?.skipHooks) {
      return data
    }

    // Check configuration mode
    const { autoPopulate } = seoConfig
  
  const isPublishing = data?._status === 'published'
  const isDraft = data?._status === 'draft'
  const isNewPost = operation === 'create'
  const isAutosave = req.context?.trigger === 'autosave'
  
  // Skip autosave if configured
  if (autoPopulate.skipAutosave && isAutosave && !isPublishing) {
    return data
  }
  
  // Apply mode-based logic
  switch (autoPopulate.mode) {
    case 'publish':
      // Only auto-populate when publishing
      if (!isPublishing) {
        return data
      }
      break
      
    case 'empty':
      // Only auto-populate if fields are empty
      if (!isNewPost && originalDoc?.meta?.title && originalDoc?.meta?.description && originalDoc?.meta?.image) {
        return data
      }
      break
      
    case 'smart':
      // Smart mode: regenerate on publish or when description seems auto-generated
      if (!isPublishing && !isNewPost) {
        // Check if description looks auto-generated (contains site name or is just title)
        const currentDesc = data.meta?.description || originalDoc?.meta?.description || ''
        const looksAutoGenerated = SEO_CONFIG.AUTO_GENERATED_KEYWORDS.some(keyword => 
          currentDesc.includes(keyword)
        )
        
        // Skip if not publishing and description doesn't look auto-generated
        if (!looksAutoGenerated && currentDesc.length > SEO_CONFIG.VALIDATION.MIN_DESCRIPTION_LENGTH) {
          return data
        }
      }
      break
      
    case 'always':
      // Always auto-populate (unless overrideExisting is false and fields exist)
      if (!autoPopulate.overrideExisting && !isNewPost) {
        // Skip if we shouldn't override and fields already exist
        if (originalDoc?.meta?.title || originalDoc?.meta?.description || originalDoc?.meta?.image) {
          return data
        }
      }
      break
  }

  // Initialize meta object if it doesn't exist
  if (!data.meta) {
    data.meta = {}
  }

  // Get current locale from request
  const locale = req.locale || 'fr'

  // Check if we should populate each field
  // In smart mode, regenerate on publish or if empty
  const isSmartMode = autoPopulate.mode === 'smart'
  
  const shouldPopulateTitle = !data.meta?.title || data.meta.title === '' || 
    (autoPopulate.overrideExisting && autoPopulate.mode === 'always') ||
    (isSmartMode && isPublishing)
  
  const shouldPopulateDescription = !data.meta?.description || data.meta.description === '' || 
    (autoPopulate.overrideExisting && autoPopulate.mode === 'always') ||
    (isSmartMode && isPublishing)
    
  // For images, always update on publish in smart mode to sync with hero image
  const shouldPopulateImage = !data.meta?.image || 
    (autoPopulate.overrideExisting && autoPopulate.mode === 'always') ||
    (isSmartMode && isPublishing)  // Always update image on publish to sync with hero
  
  // Debug: Log population decisions
  if (process.env.NODE_ENV === 'development') {
    console.log('[SEO Auto-populate] Population decisions:', {
      shouldPopulateTitle,
      shouldPopulateDescription,
      shouldPopulateImage,
      currentMetaTitle: data.meta?.title?.substring(0, 30) + '...',
      currentMetaDescription: data.meta?.description?.substring(0, 30) + '...',
      currentMetaImage: data.meta?.image,
      isPublishing,
      isSmartMode,
      mode: autoPopulate.mode,
      overrideExisting: autoPopulate.overrideExisting
    })
  }

  // Get site name based on locale
  const currentLocale = (locale || 'fr') as SupportedLocale
  const siteName = SEO_CONFIG.SITE_NAMES[currentLocale] || SEO_CONFIG.SITE_NAMES.fr

  // Extract content and title values once - we'll use them for title, description, and image
  let contentValue = null
  let titleValue = null
  
  // Extract title - handle both localized and direct formats
  if (data.title) {
    if (typeof data.title === 'object') {
      if (locale in data.title) {
        titleValue = data.title[locale]
      } else if ('fr' in data.title) {
        titleValue = (data.title as any).fr
      }
    } else {
      titleValue = data.title
    }
  }
  
  // Extract content - handle both localized and direct formats
  if (data.content) {
    if (typeof data.content === 'object') {
      // Check if it's a Lexical object (has root)
      if ('root' in data.content) {
        contentValue = data.content
      } 
      // Check if it's localized
      else if (locale in data.content) {
        contentValue = data.content[locale]
      } else if ('fr' in data.content) {
        contentValue = (data.content as any).fr
      }
    } else {
      contentValue = data.content
    }
  }

  // Auto-populate meta.title if needed
  if (shouldPopulateTitle && titleValue) {
    data.meta.title = generateSEOTitle(titleValue, siteName)
  }

  // Auto-populate meta.description if needed
  if (shouldPopulateDescription) {
    // Content and title are already extracted above
    
    // Debug logging to understand the data structure
    if (process.env.NODE_ENV === 'development') {
      console.log('[SEO Auto-populate] Step 1 - Raw data:', {
        locale,
        hasDataContent: !!data.content,
        dataContentType: typeof data.content,
        dataContentKeys: data.content && typeof data.content === 'object' ? Object.keys(data.content).slice(0, 5) : [],
        hasLocaleInContent: data.content && typeof data.content === 'object' && locale in data.content,
        hasFrInContent: data.content && typeof data.content === 'object' && 'fr' in data.content
      })
      
      console.log('[SEO Auto-populate] Step 2 - Extracted values:', {
        locale,
        hasContentValue: !!contentValue,
        contentType: typeof contentValue,
        hasRoot: contentValue && typeof contentValue === 'object' && 'root' in contentValue,
        titleValue: titleValue?.substring(0, 30) + '...'
      })
    }
    
    // Generate description from content - exactly like the manual button does
    if (contentValue && typeof contentValue === 'object' && 'root' in contentValue) {
      // Extract plain text from Lexical content
      const plainText = extractPlainTextFromLexical(contentValue)
      
      if (process.env.NODE_ENV === 'development') {
        console.log('[SEO Auto-populate] Step 3 - Text extraction:', {
          plainTextLength: plainText?.length || 0,
          plainTextPreview: plainText?.substring(0, 100) + '...',
          isEmpty: !plainText || !plainText.trim()
        })
      }
      
      if (plainText && plainText.trim()) {
        // Generate description by truncating to SEO limit
        const description = truncateText(plainText, SEO_LIMITS.description.max, true)
        data.meta.description = description
        
        if (process.env.NODE_ENV === 'development') {
          console.log('[SEO Auto-populate] ✅ SUCCESS - Description generated from content:', {
            descriptionLength: description.length,
            description: description.substring(0, 60) + '...'
          })
        }
      } else if (titleValue) {
        // Fallback to title if no content text
        data.meta.description = `${titleValue}. ${siteName}.`
        
        if (process.env.NODE_ENV === 'development') {
          console.log('[SEO Auto-populate] ⚠️ FALLBACK - Using title (no content text found)')
        }
      }
    } else if (titleValue) {
      // If no content yet (new post), use title
      data.meta.description = `${titleValue}. ${siteName}.`
      
      if (process.env.NODE_ENV === 'development') {
        console.log('[SEO Auto-populate] ℹ️ NEW POST - Using title (no content yet)')
      }
    }
  }

  // Helper to extract ID from relationship field
  const extractMediaId = (mediaField: any): number | undefined => {
    if (!mediaField) return undefined
    if (typeof mediaField === 'number') return mediaField
    if (typeof mediaField === 'string') {
      const num = parseInt(mediaField, 10)
      return !isNaN(num) ? num : undefined
    }
    if (typeof mediaField === 'object' && mediaField !== null) {
      if ('id' in mediaField) {
        const id = mediaField.id
        if (typeof id === 'number') return id
        if (typeof id === 'string') {
          const num = parseInt(id, 10)
          return !isNaN(num) ? num : undefined
        }
      }
      if ('value' in mediaField) {
        if (typeof mediaField.value === 'number') return mediaField.value
        if (typeof mediaField.value === 'string') {
          const num = parseInt(mediaField.value, 10)
          return !isNaN(num) ? num : undefined
        }
        if (typeof mediaField.value === 'object' && mediaField.value?.id) {
          const id = mediaField.value.id
          if (typeof id === 'number') return id
          if (typeof id === 'string') {
            const num = parseInt(id, 10)
            return !isNaN(num) ? num : undefined
          }
        }
      }
    }
    return undefined
  }

  // Auto-populate meta.image from configured fallback chain
  if (shouldPopulateImage) {
    if (process.env.NODE_ENV === 'development') {
      console.log('[SEO Auto-populate] Step 4 - Image extraction:', {
        hasHeroImage: !!data.heroImage,
        heroImageType: typeof data.heroImage,
        heroImageValue: data.heroImage,
        shouldUseHeroImage: seoConfig.imageFallback.includes('heroImage'),
        currentMetaImage: data.meta?.image
      })
    }
    
    // Always sync SEO image with hero image
    if (seoConfig.imageFallback.includes('heroImage')) {
      if (data.heroImage) {
        // Hero image exists - use it
        const heroImageId = extractMediaId(data.heroImage)
        if (heroImageId) {
          data.meta.image = heroImageId
          
          if (process.env.NODE_ENV === 'development') {
            console.log('[SEO Auto-populate] ✅ Hero image set as SEO image:', heroImageId)
          }
        } else if (process.env.NODE_ENV === 'development') {
          console.log('[SEO Auto-populate] ⚠️ Could not extract hero image ID')
        }
      } else {
        // Hero image removed - clear SEO image too
        data.meta.image = null
        
        if (process.env.NODE_ENV === 'development') {
          console.log('[SEO Auto-populate] ℹ️ Hero image removed, clearing SEO image')
        }
      }
    }
  }

  // If still no image and configured, try to find the first media block in content
  if (shouldPopulateImage && !data.meta.image && seoConfig.imageFallback.includes('firstMediaBlock')) {
    // contentValue is already extracted above for the description
    // Just reuse it here
    if (contentValue && typeof contentValue === 'object' && 'root' in contentValue) {
      const firstMediaBlock = findFirstMediaBlock(contentValue.root)
      if (firstMediaBlock) {
        data.meta.image = firstMediaBlock
        
        if (process.env.NODE_ENV === 'development') {
          console.log('[SEO Auto-populate] ✅ First media block set as SEO image:', firstMediaBlock)
        }
      } else if (process.env.NODE_ENV === 'development') {
        console.log('[SEO Auto-populate] ℹ️ No media blocks found in content')
      }
    }
  }

    return data
  } catch (error) {
    // Log the error but don't break the save operation
    console.error('Error in autoPopulateSEO hook:', error)
    // Return data unchanged if there's an error
    return data
  }
}

/**
 * Helper function to find the first media block in Lexical content
 */
function findFirstMediaBlock(root: any): number | undefined {
  if (!root || !root.children) return undefined

  // Helper to extract ID from media field
  const extractId = (media: any): number | undefined => {
    if (!media) return undefined
    if (typeof media === 'number') return media
    if (typeof media === 'string') {
      const num = parseInt(media, 10)
      return !isNaN(num) ? num : undefined
    }
    if (typeof media === 'object' && media !== null) {
      if (media.id) {
        if (typeof media.id === 'number') return media.id
        if (typeof media.id === 'string') {
          const num = parseInt(media.id, 10)
          return !isNaN(num) ? num : undefined
        }
      }
      if (media.value) {
        if (typeof media.value === 'number') return media.value
        if (typeof media.value === 'string') {
          const num = parseInt(media.value, 10)
          return !isNaN(num) ? num : undefined
        }
        if (typeof media.value === 'object' && media.value?.id) {
          if (typeof media.value.id === 'number') return media.value.id
          if (typeof media.value.id === 'string') {
            const num = parseInt(media.value.id, 10)
            return !isNaN(num) ? num : undefined
          }
        }
      }
    }
    return undefined
  }

  for (const child of root.children) {
    // Check if this is a block node
    if (child.type === 'block' && child.fields) {
      // Check if it's a media block or gallery
      if (child.fields.blockType === 'mediaBlock' && child.fields.media) {
        const mediaId = extractId(child.fields.media)
        if (mediaId) return mediaId
      } else if (child.fields.blockType === 'gallery' && child.fields.images?.length > 0) {
        // For gallery, use the first image
        const firstImage = child.fields.images[0]
        const imageId = extractId(firstImage)
        if (imageId) return imageId
      }
    }
    
    // Recursively check children
    if (child.children) {
      const found = findFirstMediaBlock(child)
      if (found) return found
    }
  }

  return undefined
}